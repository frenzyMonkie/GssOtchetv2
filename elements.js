// Рендерим лейаут
function Greeting(name) {
    return element(
            'h1',
            { className: 'greeting' },
            'Hello ', element('i', null, name), '. Welcome!'
    ); // Все аргументы с 3 и далее, указанные через запятую - будут объединены в jsx.
    // Значит сюда можно прокидывать распаковываемые списки, задекларированные в более удобном для чтения и редактирования месте.
}
var a = <h1>Привет</h1>
var b = <h1>Пока</h1>


// каждый инпут - элемент зависит от:
// 1. Названия подкатегории отчёта
// 2. Названия сектора (nk9) работ (возможно будет в форме поля а не категории)
// 3. Порядкового номера в случае множественных одинаковых полей
// 4. Название отдельного поля, которое соответствует полю в базе данных
// category > record(~sql_row) > recordId > fields
// (смена/выезд/расход/работа_мсг_план/работа_мсг_факт/работа_мсг_факт_накопительный/работа_накопительная/работы_сопроводительные/дебит_план/дебит_факт/УГВ_план/УГВ_факт)


// Т.е. будет чтение, удаление, апдейт и добавление исходя из данных
// Запись: this.category + this.recordIdx > this.fieldName
// Это значит что в инстанс класса должны сохраняться эти переменные

// Должен быть реестр элементов:
// 1. Сам элемент, его id и все параметры
// 2. Набор ключей, определяющий его местоположение в системе. {category: tachki; recordName: vuezd; recordIdx: 5; fields: {tachka: "Кран 25т", hrs: 11, sector: nk9}}

// Набор создается под каждый конечный элемент. Список таких наборов хранится и пользуется для случаев
// 1. Добавления - автоматического и вручную, их отрисовки где надо, удаления
// 2.

// Разве что для временного хранения подойдет отдельный такой класс. И для  формирования отчёта для отправки, и для размещения загруженных данных с сервера.
// Возможно нужен наоборот, список всех компонентов, и по ним итерироваться для случаев storeLocally, ComposeReport, RouteDownloadedData (т.е. и обратная связь от хранилища к элементам нужна)
// Тогда либо добавить их в список и по ним итерироваться, но тогда и обновлять их нужно в списке, т.е. сначала добавить в словарь/список, и уже из него рендерить.
// list.insert(element) > element[0].render()

// Либо добавить функцию в crud, чтобы при каждом триггере они обновляли промежуточное хранилище.

// фейспалм.  document.getElementById и всё.
// по сути работа скорее во взаимоувязыавании полей принятых json и элементов document.getElementById.
// а при формировании отправки и хранения - автоматически при каждом обновлении - апдейтить "снимок-слепок", просто иначе мы не сможем понять как найти все новые элементы,
// кроме как, повторюсь, запускания их прямо из словаря/списка.


class localStorageManager {
    constructor() {
        this.elementReg = []; // Нужна словарная структура, форма пока смутно.
        // Как будем определять, к каким категориям относится каждый нажимаемый инпут?
        // Видимо, в параметры react.Component(createElement) будем прокидывать все эти идентификаторы
        // С идентификаторами ладно, как проиндексировать все элементы в этот менеджер, если у каждого элемента свои поля? Нужно ли?
        // Скорее нужно расширить react.Component функциями CRUD.
    }

    set element(fieldset){
        this.elementReg.push(fieldset);
    }
    read(identifiers){
        return this.elementReg[identifiers]
    }
    update(identifiers, fieldset){
        this.elementReg[identifiers] = fieldset
    }
    delete(identifiers){
        // удалить через фильтрацию
    }

}

